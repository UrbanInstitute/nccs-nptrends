---
title: "Relabeling Qualtrics Variables"
execute:
  warning: false
  message: false
---

```{r, include=FALSE, echo=FALSE}
library( haven )
library( dplyr )
library( tidyr )
library( epoxy )
library( memisc )
library( labelled )

# SOURCE PREVIOUS STEPS 

options( knitr.duplicate.label = "allow" )

knitr::purl( "3_00-YEAR-THREE.qmd" )   # convert QMD to R script
source(      "3_00-YEAR-THREE.R"   )   # run all chunks in prior step
file.remove( "3_00-YEAR-THREE.R"   )   # delete script after execution
```

```{r, eval=F, echo=F}
# LOAD SURVEY DATA FROM SAVED FILE AFTER LAST CHAPTER

fpath     <- "DATA-PREP/03-year-three/02-data-intermediate/"
fname     <- "SURVEYDF-Y3.csv"
survey_df <- read.csv( paste0( fpath, fname ) )

# LOAD DATA DICTIONARY 

dd <- readxl::read_xlsx( 
        "../data-dictionaries/dd-nptrends-year-03.xlsx", 
        sheet = "data dictionary" )
```

Qualtrics uses some random values like -99 to encode for things like skipped questions, "not sure" categories, or "not applicable" answers. Currently one needs to a dictionary to look up every variable to understand what each value means.

In addition, some response categories are confusing because they equate to a missing response. For example, from an analytical perspective an answer of "not sure" and skipping the question completely both equate to a missing value when the response categories are yes or no.

The **memisc** package was designed for working with survey data. It allows you to label response categories in the data and also designate different types of missingness (e.g. Unsure, N/A, and -99 can all be coded as missing).

Several factor and boolean variables in this survey data set have inconsistent coding. They are recoded in this section and the decision criteria are documented for inspection and review.

```{r, echo=F}
# Functions to convert survey variable to survey
# item with missingness and variable labels

recode_x <- function( x, pattern, replace ){
  x <- stringi::stri_replace_all_fixed( x, pattern, replace, vectorize_all=F  )
  if( any( pattern=="NA" )){
    na.val <- replace[ pattern == "NA" ] 
    x[ is.na(x) ] <- na.val   
  }
  return(x)
}


as_memisc_item <- function( x, val.x, lab.x, missing.x=NULL ){
  
  # add unnamed values 
  diff <- setdiff( x, val.x ) |> na.omit()
  val.x <- c( val.x, diff )
  lab.x <- c( lab.x, diff )
  
  # assign labels 
  names( val.x ) <- lab.x
  
  # convert to memisc survey item
  x <- x |> 
    memisc::as.item(
      labels = val.x,
      missing.values = missing.x ) 
  
  return(x)  
}

# wrapper for both steps

f <- function( x, pattern, replace, val.x, lab.x, missing.x=NULL ){
  x <- recode_x( x, pattern, replace )
  x <- as_memisc_item( x, val.x, lab.x, missing.x )
  return(x)
}

# add question labels for columns k

add_q_details <- function( x, df ){
  
  v <- df[[x]]
  
  # add question label attribute
  q.label <- dd$vlabel[ dd$vname == x ] |> 
    na.omit() |>
    paste0( collapse=" ;; " )
 
  # add variable type attribute
  q.type <- dd$type[ dd$vname == x ] |> 
    na.omit() |>
    paste0( collapse=" ;; " )
  
  # add question text
  q.text <- dd$description[ dd$vname == x ] |> na.omit()
    
  wording( v )     <- q.label
  description( v ) <- paste0( "TYPE: ", q.type )
  annotation( v )["QUESTION TXT"] <- q.text 
  
  return( v )
}

# apply rules to specific columns K

recode_columns <- function( df, k, pattern=NULL, replace=NULL, val.x, lab.x, mis.x=NULL, RULES=NULL ){
  
  if( ! is.null(RULES) )
    {
      rules <- parse_rules( RULES )          
      pattern <- rules[[ "pattern" ]]
      replace <- rules[[ "replace" ]]    
    }


  df[ k ] <- lapply( df[k], f, pattern, replace, val.x, lab.x, mis.x )
  df[ k ] <- purrr::map( k, add_q_details, df )
  return(df)
}


# ALTERNATIVE REPRESENTATION OF RECODING RULES

parse_rules <- function(x) {
  L <- strsplit( x, "=>>|~" )
  L <- lapply( L, trimws )
  m <- matrix( unlist(L), byrow=T, ncol=2 )
  d <- as.data.frame( m )
  names( d ) <- c("pattern","replace")
  return( d )
}


# CLEANING NON-NUMERIC VALUES FROM NUMERIC RESPONSES

keep_numbers <- function(x){
  x <- gsub( "[$,]", "", x ) %>% as.numeric()
  x[ x == -99 ] <- Inf
  return(x)
}
```

```{r, eval=F, echo=F}

#####
#####   FUNDRAISING EXAMPLE
#####

# APPLY TO COLUMNS K:
COLUMNS <-  fundraise_skrcv_qns_bool

# VALUES FOR RECODING 
pattern <- c( "(select all that apply)", "-99" )
replace <- c( "1", "0" )

# MEMISC LABELS AND MISSING VALUE CODES  
values  <- c("0", "1")
labels  <- c( "No", "Yes" )
missing <- "UNSURE"

d2 <- dplyr::select( survey_df, all_of( COLUMNS ) )
d3 <- recode_columns( d2, k=COLUMNS, pattern, replace, values, labels, missing )
codebook( d3 )
```

```{r, eval=F, echo=F}

# ALTERNATIVE REPRESENTATION OF RECODING RULES

RULES <- c(     ### -----------------------------
       
  "   (select all that apply)   =>>   1   ", 
  "                       -99   =>>   0   "    

)               ### ------------------------------


# VALUES FOR RECODING 
rules <- parse_rules( RULES )
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]

# MEMISC LABELS AND MISSING VALUE CODES  
values  <- c("0", "1")
labels  <- c( "No", "Yes" )
missing <- "UNSURE"

d3 <- recode_columns( d2, k=COLUMNS, pattern, replace, values, labels, missing )
codebook( d3 )

```

```{r, eval=F, echo=F}
# NUMERIC ENCODING WITH MEMISC TO PRESERVE MISSING CASES
#
#   We want to use a number to preserve the numeric data,
#   but we don't want to number to impact computations.
#   Ideally the user has to remove missing values before 
#   any computations so that the missing values are not
#   polluting the statistics.

#   Options: -n (n being any value), NaN, Inf

survey_df <- read.csv( paste0( fpath, fname ) )
x <- survey_df[[ "FndRaise_MajGift_Amt" ]]
sum( x == -99, na.rm=T )  # 18 missing values


x[ x == -99 ] <- -1   # user might calculate without realizing
x[ x == -99 ] <- NaN  # can't calculate until dropping and distinct from NA;
                      #   - memisc doesn't recognize as missing value though
x[ x == -99 ] <- Inf  # this one works 


keep_numbers <- function(x){
  x <- gsub( "[$,]", "", x ) %>% as.numeric()
  x[ x == -99 ] <- Inf
  return(x)
}

x <- survey_df[[ "FndRaise_MajGift_Amt" ]]
x <- keep_numbers( x )
x <- memisc::as.item( x, missing.values=Inf )

codebook( x )

   #   Storage mode: double
   #   Measurement: interval
   #   Missing values: Inf
   # 
   #   Values                  N Percent
   #                                  
   #      M (unlab.mss.)      18     2.2
   #   NA M                  156    19.0
   #                                  
   #        Min:       0.010            
   #        Max: 1000000.000            
   #       Mean:    5935.894            
   #   Std.Dev.:   44801.714

# missing values preserved in memisc object
x %>% print()
x %>% include.missings() %>% as.integer()


# converted to NA when saving to file
x %>% as.numeric() %>% summary()
```

# Yes/No Questions

| Original Value | Description    | Recode Value | Code as Missing ? |
|----------------|----------------|--------------|-------------------|
| Yes            | Yes            | 1            | No                |
| No             | No             | 0            | No                |
| Unsure         | Unsure         | 97           | Yes               |
| N/A            | Not Applicable | 98           | Yes               |
| -99            | Incomplete     | 99           | Yes               |
| NA             | Unanswered     | NA           | Yes               |

```{r}
# APPLY TO COLUMNS K:
bool_qns <- 
  c( program_change_qns_bool, 
     fundraise_qns_bool, 
     finance_chng_qns_bool, 
     leadership_chng_qns_bool )

COLUMNS <-  bool_qns

# VALUES THAT NEED RECODING
RULES <- c(
  
           "  Yes    =>>    1    ", 
           "  No     =>>    0    ", 
           "  Unsure =>>    97   ", 
           "  N/A    =>>    98   ", 
           "  -99    =>>    99   "   )

rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]


# MEMISC LABELS AND MISSING VALUE CODES
values  <- c( 0, 1, 97, 98, 99 )
labels  <- c( "No", "Yes", "Unsure", "Not Applicable", "N/A" )
missing <- c( 97, 98, 99 )

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
# codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

| Original Value | Description    | Recode Value | Code as Missing ? |
|----------------|----------------|--------------|-------------------|
| Yes            | Yes            | 1            | No                |
| No             | No             | 2            | No                |
| Unsure         | Unsure         | 3            | Yes               |
| N/A            | Not Applicable | 98           | Yes               |
| -99            | Incomplete     | 99           | Yes               |
| NA             | Unanswered     | NA           | Yes               |

```{r}
# APPLY TO COLUMNS K:

COLUMNS <- cares_qns_bool

# VALUES THAT NEED RECODING
RULES <- c(  "  Yes    =>>  1    ", 
             "  No     =>>  2    ", 
             "  Unsure =>>  3    ", 
             "  N/A    =>>  98   ", 
             "  -99    =>>  99   "   )

rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]


# MEMISC LABELS AND MISSING VALUE CODES
values  <- c( 1, 2, 3, 98, 99 )
labels  <- c( "Yes", "No", "Unsure", "Not Applicable", "N/A" )
missing <- c( 3, 98, 99 )

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
# codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

# Single Checkboxes

These questions are presented as a checkbox to the respondent. They indicate an affirmative answer to the question.

## Seek or Receive Fundraising Questions

```{r, eval=F, echo=F}

lapply( survey_df[ fundraise_skrcv_qns_bool ], table, useNA="ifany" )
```

These checkboxes are ticked by the respondent to indicate if they have sought or received funding from a specific source.

| Original Value | Description        | Recode Label | Recode Value | Code as Missing? |
|---------------|---------------|---------------|---------------|---------------|
| 1              | Checkbox Checked   | Yes          | 1            | No               |
| NA             | Checkbox Unchecked | No           | 0            | No               |
| All NA         | Unanswered         | NA           | NA           | Yes              |

*ALL NA* refers to no responses on all questions in this entire question group (i.e. the respondent skipped the section).

```{r}
# APPLY TO COLUMNS K:
COLUMNS <-  fundraise_skrcv_qns_bool


# ALL RESPONSES NA IN GROUP:
# indication that the question
# was skipped by the respondent

row.id <- apply( survey_df[ COLUMNS ], 
                 MARGIN = 1, 
                 FUN = function(x) all(is.na(x)) ) 

# NA means "no"

na_to_zero <- function(x){
  x[ is.na(x) ] <- 0
  return(x)
}

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( na_to_zero )

# if they do not respond "yes" 
# to at least one question then
# assume they skipped them all

zero_to_na <- function( x, rowid ){
  x[ rowid ] <- NA
  return(x)
}

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( zero_to_na, row.id )



# VALUES THAT NEED RECODING

RULES <- c(    
  
  "    1      =>>    1    ", 
  "   NA      =>>    0    "    )


rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]

# MEMISC LABELS AND MISSING VALUE CODES 
values  <- c( "0", "1" )
labels  <- c( "No", "Yes" )
missing <- NA

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
# codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

## Regulation Checkboxes

These questions are presented as a checkbox to the user to indicate that a question is not applicable. "Yes" here means "Yes, this question is not applicable".

| Original Value | Description      | Recode Label | Recode Value | Code as Missing ? |
|---------------|---------------|---------------|---------------|---------------|
| 1              | Checkbox Checked | Yes          | 1            | No                |
| NA             | Unanswered       | No           | 0            | No                |
| 22             | Checkbox Checked | Yes          | 1            | No                |
| 21             | Unchecked Box    | No           | 0            | No                |

```{r}
# APPLY TO COLUMNS K:

# exclude OTHER TXT question
other <- which( regulation_qns == "Regulations_Other_TEXT" )
COLUMNS <-  regulation_qns[ - other  ]


# "did not contact any agencies":
# ~ NONE CONTACTED

dnc.rows <- survey_df$Regulations == 21 

# all rows NA: 
# question skipped by respondent

na.rows <- is.na( survey_df$Regulations )


# NA means "NO"

na_to_zero <- function(x){
  x[ is.na(x) ] <- 0
  return(x)
}

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( na_to_zero )


# if they responded "NONE CONTACTED" (21) 
# to the first question code
# the rest as "NONE CONTACTED"

zero_to_dnc <- function( x, rowid ){
  x[ rowid ] <- "NONE"
  return(x)
}

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( zero_to_dnc, rowid=dnc.rows )

# if the first question was NA 
# code all as missing ("no response")

zero_to_noresp <- function( x, rowid ){
  x[ rowid ] <- "_NR_"
  return(x)
}

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( zero_to_noresp, rowid=na.rows )


# VALUES THAT NEED RECODING

RULES <- c(    "   22    =>>     1                ",
               "   21    =>>     NONE             ",
               "   NA    =>>     _NA_             "    )


rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]


# MEMISC LABELS AND MISSING VALUE CODES 
values  <- c( "0", "1", "NONE", "_NR_", "_NA_" )
labels  <- c( "No", "Yes", "None Contacted", "No Response", "Missing" )
missing <- "_NA_"

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[2:3] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1:2] ] ))
```

## Staffing Plans

These questions are presented as a checkbox to the user to indicate that a question is not applicable. "Yes" here means "Yes, this question is not applicable".

| Original Value | Description      | Recode Label | Recode Value | Code as Missing ? |
|---------------|---------------|---------------|---------------|---------------|
| 1              | Checkbox Checked | Yes          | 1            | No                |
| NA             | Unanswered       | No           | 0            | No                |

```{r}
# APPLY TO COLUMNS K:
COLUMNS <-  staffing_plans


# ALL RESPONSES NA IN GROUP:
# indication that the question
# was skipped by the respondent

row.id <- apply( survey_df[ COLUMNS ], 
                 MARGIN = 1, 
                 FUN = function(x) all(is.na(x)) ) 

# VALUES THAT NEED RECODING

RULES <- c(    
          
             "    1    =>>     1   ", 
             "   NA    =>>     0   "   )


rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]

# NA means "no"

na_to_zero <- function(x){
  x[ is.na(x) ] <- 0
  return(x)
}

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( na_to_zero )

# if they do not respond "yes" 
# to at least one question then
# assume they skipped them all

zero_to_na <- function( x, rowid ){
  x[ rowid ] <- NA
  return(x)
}

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( zero_to_na, row.id )

# MEMISC LABELS AND MISSING VALUE CODES 
values  <- c( "0", "1" )
labels  <- c( "No", "Yes" )
missing <- NA

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[2] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

## N/A Checkboxes

These questions are presented as a checkbox to the user to indicate that a question is not applicable. "Yes" here means "Yes, this question is not applicable".

### Staff Forecasts

We see three four cases:

-   All answered
-   Only answer for 2022 but don't forecast 2023
-   Answer "does not apply to me"
-   Answer "does apply" but then don't report numbers

We create an imputed version of 2023 numbers using 2022 numbers for missing cases (new variable x_2023 is saved as x_2023_imp for "imputed" ).

Replace "OK" in the not applicable field with "UNSURE" if they report no staff numbers. These will become NA (missing) when the dataset is saved.

```{r, echo=F}
# staff.q <- c("Staff_Fulltime_2022","Staff_Fulltime_2023","Staff_Fulltime_NA")
# survey_df[ 141:150, staff.q  ] %>% dput()

df.demo <- structure(list(Staff_Fulltime_2022 = c(100L, 1L, 210L, 1L, 0L, 
NA, NA), Staff_Fulltime_2023 = c(110L, 1L, 225L, NA, NA, NA, 
NA), Staff_Fulltime_NA = c(0, 0, 0, 0, 0, 1, 0)), row.names = c(142L, 
144L, 145L, 143L, 146L, 141L, 150L), class = "data.frame")

df.demo
```

After imputation of 2023 responses (use 2022 values):

```{r, echo=F}
na.2022 <- is.na( df.demo$Staff_Fulltime_2022 )
na.2023 <- is.na( df.demo$Staff_Fulltime_2023 )
both.na <- na.2022 & na.2023

df.demo$Staff_Fulltime_NA[ is.na( df.demo$Staff_Fulltime_NA) ] <- 0
df.demo$Staff_Fulltime_NA[ df.demo$Staff_Fulltime_NA == 0 & both.na ] <- 99

# impute missing 2023 values with 2022 values 
df.demo$Staff_Fulltime_2023[ na.2023 ] <- df.demo$Staff_Fulltime_2022[ na.2023 ]

df.demo
```

```{r}
impute_staff <- function( df, v2022, v2023, vNA ){
  
  x.2022 <- df[[ v2022 ]]
  x.2023 <- df[[ v2023 ]]
  x.NA   <- df[[ vNA   ]]
  
  na.2022 <- is.na( x.2022 )
  na.2023 <- is.na( x.2023 )
  both.na <- na.2022 & na.2023
  
  # Not applicable is "unsure"
  x.NA[ is.na( x.NA ) ] <- 0
  x.NA[ x.NA == 0 & both.na ] <- 99
  
  # impute missing 2023 values with 2022 values 
  x.2023[ na.2023 ] <- x.2022[ na.2023 ]
  v2023i <- paste0( v2023, "_imp" )
  
  df[[ v2023i ]] <- x.2023
  df[[   vNA ]] <- x.NA
  
  return(df)
}


survey_df <- 
  survey_df %>% 
  impute_staff( v2022="Staff_Fulltime_2022", 
                v2023="Staff_Fulltime_2023", 
                vNA="Staff_Fulltime_NA" )

survey_df <- 
  survey_df %>% 
  impute_staff( v2022="Staff_Parttime_2022", 
                v2023="Staff_Parttime_2023", 
                vNA="Staff_Parttime_NA" )

survey_df <- 
  survey_df %>% 
  impute_staff( v2022="Staff_Boardmmbr_2022", 
                v2023="Staff_Boardmmbr_2023", 
                vNA="Staff_Boardmmbr_NA" )

survey_df <- 
  survey_df %>% 
  impute_staff( v2022="Staff_RegVlntr_2022", 
                v2023="Staff_RegVlntr_2023", 
                vNA="Staff_RegVlntr_NA" )

survey_df <- 
  survey_df %>% 
  impute_staff( v2022="Staff_EpsdVltnr_2022", 
                v2023="Staff_EpsdVltnr_2023", 
                vNA="Staff_EpsdVltnr_NA" )

survey_df <- 
  survey_df %>% 
  impute_staff( v2022="Staff_AmerVlntr_2022", 
                v2023="Staff_AmerVlntr_2023", 
                vNA="Staff_AmerVlntr_NA" )

survey_df <- 
  survey_df %>% 
  impute_staff( v2022="Staff_PdCnslt_2022", 
                v2023="Staff_PdCnslt_2023", 
                vNA="Staff_PdCnslt_NA" )
```

| Original Value | Description                          | Recode Label   | Recode Value | Code as Missing ? |
|-------------|---------------------|-------------|-------------|-------------|
| 1              | Yes, this question is not applicable | Not Applicable | 1            | No                |
| NA             | No, this question applies to me      | OK             | 1            | No                |
| All NA         | N/A response conflicts               | Unsure         | 99           | Yes               |

```{r}
# APPLY TO COLUMNS K:
COLUMNS <-  staff_qns_bool

# VALUES THAT NEED RECODING

RULES <- c(    
          
             "    1    =>>      1    ", 
             "    0    =>>      0    ", 
             "   99    =>>     99    "     )


rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]

# MEMISC LABELS AND MISSING VALUE CODES 
values  <- c( "0", "1", "99" )
labels  <- c( "OK", "N/A", "UNSURE" )
missing <- "UNSURE"

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

### Reserve Questions

| Original Value | Description                          | Recode Label | Recode Value | Code as Missing ? |
|-------------|---------------------|-------------|-------------|-------------|
| 1              | Yes, this question is not applicable | N/A          | 1            | No                |
| NA             | This question applies to me          | 0            | OK           | No                |
| All NA         | N/A response conflicts               | Unsure       | 99           | Yes               |

```{r}
# APPLY TO COLUMNS K:
COLUMNS <-  reserve_qns_bool

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( na_to_zero )

# did not respond to the reserve questions
no.resp <- is.na( survey_df$Reserves_Est )
survey_df$Reserves_NA_X[ no.resp ] <-  99
    

# VALUES THAT NEED RECODING

RULES <- c(    
          
             "    1    =>>     1   ", 
             "    0    =>>     0   "   )


rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]


# MEMISC LABELS AND MISSING VALUE CODES 
values  <- c( "0", "1", "99" )
labels  <- c( "OK", "N/A", "Did Not Answer" )
missing <- "99"

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

### People Served Questions

| Original Value | Description                          | Recode Label | Recode Value | Code as Missing ? |
|-------------|---------------------|-------------|-------------|-------------|
| 1              | Yes, this question is not applicable | N/A          | 1            | No                |
| NA             | This question applies to me          | 0            | OK           | No                |
| All NA         | N/A response conflicts               | Unsure       | 99           | Yes               |

```{r}
# APPLY TO COLUMNS K:
COLUMNS <-  people_served_qns_bool


# ALL RESPONSES NA IN GROUP:
# indication that the question
# was skipped by the respondent

people_qns <- c( "PplSrv_NumServed", "PplSrv_NumWait" )

row.id <- apply( survey_df[ people_qns ], 
                 MARGIN = 1, 
                 FUN = function(x){ all(is.na(x)) } ) 


# NA means "no"

na_to_zero <- function(x){
  x[ is.na(x) ] <- 0
  return(x)
}

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( na_to_zero )

# if they do not respond "yes" 
# to at least one question then
# assume they skipped them all

zero_to_99 <- function( x, rowid ){
  x[ rowid ] <- 99
  return(x)
}

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( zero_to_99, row.id )

    

# VALUES THAT NEED RECODING

RULES <- c(    "    1    =>>     1    ", 
               "    0    =>>     0    ",
               "   NA    =>>   _NA_   "      )


rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]


# MEMISC LABELS AND MISSING VALUE CODES 
values  <- c( "0", "1", "99", "_NA_" )
labels  <- c( "OK", "N/A", "No response", "No response" )
missing <- c( "99", "_NA_" )

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

# Multi-selection Inputs

These questions offer the user with multiple options to select one from. Since the options are ordered categories, they are coded on an ordinal scale.

## Increase - Decrease Questions

There 2 questions that ask respondents to define changes via an increase or decrease relative to previous years. They are recoded on an ordinal scale.

## Changes in Demand Questions

| Original Value | Description   | Recode Label | Recode Value | Code as Missing ? |
|---------------|---------------|---------------|---------------|---------------|
| Increase       | Increase      | Increase     | 2            | No                |
| Stay the same  | Stay the same | Unchanged    | 1            | No                |
| Decrease       | Decrease      | Decrease     | 0            | No                |
| -99            | Incomplete    | No           | 99           | Yes               |
| NA             | Unanswered    | NA           | NA           | Yes               |

```{r}
# APPLY TO COLUMNS K:
COLUMNS <-  demand_fct_qns

# VALUES THAT NEED RECODING

RULES <- c(    
          
             "   0    =>>     0   ",
             "   1    =>>     1   ", 
             "  98    =>>     2   "     )


rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]

# MEMISC LABELS AND MISSING VALUE CODES 
values  <- c( 2, 1, 0 )
labels  <- c( "Increase", "Unchanged", "Decrease" )
missing <- NA

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

## Changes in Fundraising Questions

| Original Value                             | Description             | Recode Label           | Recode Value | Code as Missing ? |
|---------------|---------------|---------------|---------------|---------------|
| Increased significantly (by more than 10%) | Largest Increase        | Increase Significantly | 5            | No                |
| Increased moderately (by less than 10%)    | Second Largest Increase | Increase Moderately    | 4            | No                |
| Stayed more or less the same               | Third Largest Increase  | Unchanged              | 3            | No                |
| Decreased moderately (by less than 10%)    | Fourth Largest Increase | Decrease Moderately    | 2            | No                |
| Decreased significantly (by more than 10%) | Fifth Largest Increase  | Decrease Significantly | 1            | No                |
| Unsure                                     | Unsure                  | Unsure                 | 99           | Missing           |
| -99                                        | Incomplete              | Incomplete             | 98           | Yes               |
| N/A                                        | Not Applicable          | Not Applicable         | 97           | Yes               |
| NA                                         | Unanswered              | NA                     | NA           | Yes               |

```{r}
# APPLY TO COLUMNS K:
COLUMNS <-  fundraise_change_qns_fct

# VALUES THAT NEED RECODING

row.id <- apply( survey_df[ COLUMNS ], 
                 MARGIN = 1, 
                 FUN = function(x) all(is.na(x)) )

RULES <- c(    
          
     "   Increased significantly (by more than 10%)    =>>     5   ",
     "      Increased moderately (by less than 10%)    =>>     4   ",
     "                 Stayed more or less the same    =>>     3   ",
     "      Decreased moderately (by less than 10%)    =>>     2   ",
     "   Decreased significantly (by more than 10%)    =>>     1   ",
     "                                           98    =>>     0   ",
     "                                           99    =>>     X   "  )
 
rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]


all_na <- function( x, rowid ){
  x[ rowid ] <- NA
  return(x)
}

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( all_na, row.id )


# MEMISC LABELS AND MISSING VALUE CODES 
values  <- c( 5, 4, 3, 2, 1, 0, "X"  )
labels  <- c( "Increase Significantly", "Increase Moderately", 
              "Unchanged", "Decrease Moderately", "Decrease Significantly", 
              "Unsure", "Not Applicable" )
missing <- c( "X" )

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

# Level of Importance Questions

There are 2 questions that ask respondents to rank the importance of volunteers and donors respectively. However, both sets of options' are not identical. Hence, they are recoded to common values for reproducibility.

## Volunteer Importance

| **Original Value**                                                                       | **Description**       | **Recode Label**     | **Recode Value** | **Code as Missing ?** |
|----------------------------|-----------|-----------|-----------|-----------|
| Essential - we depend entirely on volunteers to carry out our mission and goals          | Maximum Importance    | Essential            | 5                | No                    |
| Very important - we depend on volunteers for a wide range of tasks, but not all          | Second Most Important | Very Important       | 4                | No                    |
| Somewhat important - we depend on volunteers for several key tasks                       | Third Most Important  | Somewhat Important   | 3                | No                    |
| Not very important - we depend on volunteers for only non-essential tasks                | Fourth Most Important | Not Very Important   | 2                | No                    |
| Not at all important - we could carry out our mission and goals without using volunteers | Fifth Most Important  | Not At All Important | 1                | No                    |
| We do not use volunteers                                                                 | Sixth Most Important  | Not Used             | 0                | No                    |
| -99                                                                                      | Incomplete            | Incomplete           | 99               | Yes                   |
| NA                                                                                       | Unanswered            | NA                   | NA               | Yes                   |



```{r}
# APPLY TO COLUMNS K:
COLUMNS <-  volimportance_qns_fct

# VALUES THAT NEED RECODING

RULES <- c(    

"           Essential - we depend entirely on volunteers to carry out our mission and goals    =>>     1   ",
"           Very important - we depend on volunteers for a wide range of tasks, but not all    =>>     2   ",
"                        Somewhat important - we depend on volunteers for several key tasks    =>>     3   ",
"                 Not very important - we depend on volunteers for only non-essential tasks    =>>     4   ",
"  Not at all important - we could carry out our mission and goals without using volunteers    =>>     5   ",
"                                                                  We do not use volunteers    =>>     99  "    )

rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]

# MEMISC LABELS AND MISSING VALUE CODES 
values  <- c( 1, 2, 3, 4, 5, 99 )
labels  <- c( "Essential", "Very Important", "Somewhat Important", 
              "Not Very Important", "Not At All Important", "Not Used" )
missing <- NA

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

## Donor Importance

| Original Value                                                                                    | Description           | Recode Label         | Recode Value | Code as Missing ? |
|--------------------------------|----------|----------|----------|----------|
| Essential, we depend entirely on individual donations to carry out our mission and goals          | Maximum Importance    | Essential            | 1            | No                |
| Very important, we depend on individual donations for a wide range of activities, but not all     | Very Important        | 2                    | No           |                   |
| Important, we depend on individual donations for several key activities                           | Third Most Important  | Somewhat Important   | 3            | No                |
| Not very important, we depend on individual donations for only non-essential activities           | Fourth Most Important | Not Very Important   | 4            | No                |
| Not at all important, we could carry out our mission and goals without donations from individuals | Fifth Most Important  | Not At All Important | 5            | No                |
| We do not receive donations from individuals                                                      | Sixth Most Important  | Not Used             | 6            | No                |
| -99                                                                                               | Incomplete            | Incomplete           | 0            | Yes               |
| NA                                                                                                | Unanswered            | NA                   | NA           | Yes               |

```{r}
# APPLY TO COLUMNS K:
COLUMNS <-  donimportance_qns_fct

# VALUES THAT NEED RECODING

RULES <- c(    

  "          Essential, we depend entirely on individual donations to carry out our mission and goals  =>>  1  ",
  "     Very important, we depend on individual donations for a wide range of activities, but not all  =>>  2  ",
  "                           Important, we depend on individual donations for several key activities  =>>  3  ",
  "           Not very important, we depend on individual donations for only non-essential activities  =>>  4  ",
  " Not at all important, we could carry out our mission and goals without donations from individuals  =>>  5  ",
  "                                                      We do not receive donations from individuals  =>>  99 "  )


rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]

# MEMISC LABELS AND MISSING VALUE CODES 
values  <- c( 1, 2, 3, 4, 5, 99  )
labels  <- c( "Essential", "Very Important", 
              "Somewhat Important", "Not Very Important", 
              "Not At All Important", "Not Used" )
missing <- NA

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

# Frequency Questions

These questions ask respondents to rank the frequency at which they engage in an activity.

| Original Value      | Description          | Recode Label        | Recode Value | Code as Missing ? |
|---------------|---------------|---------------|---------------|---------------|
| More Often Than Not | Most Frequent        | More Often Than Not | 5            | No                |
| Frequently          | Second Most Frequent | Frequently          | 4            | No                |
| Occasionally        | Third Most Frequent  | Occasionally        | 3            | No                |
| Rarely              | Fourth Most Frequent | Rarely              | 2            | No                |
| Never               | Fifth Most Frequent  | Occasionally        | 1            | No                |
| -99                 | Incomplete           | Incomplete          | 99           | Yes               |
| NA                  | Unanswered           | NA                  | NA           | Yes               |

```{r}
# APPLY TO COLUMNS K:
COLUMNS <-  extaffairs_qns_fct

# VALUES THAT NEED RECODING

RULES <- c(    

     "    More Often Than Not    =>>     5   ",
     "             Frequently    =>>     4   ",
     "           Occasionally    =>>     3   ",
     "                 Rarely    =>>     2   ",
     "                  Never    =>>     1   "   )
     
rules <- parse_rules( RULES )          
pattern <- rules[[ "pattern" ]]
replace <- rules[[ "replace" ]]

# MEMISC LABELS AND MISSING VALUE CODES 
values  <- c( 5, 4, 3, 2, 1 )
labels  <- c( "More often than not", "Frequently", 
              "Occasionally", "Rarely", "Never"  )
missing <- NA

# RECODE VARIABLES 
survey_df <- 
  survey_df %>% 
  recode_columns( k=COLUMNS, pattern, replace, values, labels, missing )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

# Integer Inputs

These questions accept an integer input from users to indicate the number of staff they have, people they served, or donors they have.

| Original Value | Description                       | Recode Label | Recode Value  | Code as Missing ? |
|---------------|---------------|---------------|---------------|---------------|
| Whole Number   | Number of Staff, People or Donors | NA           | Integer Value | No                |
| N/A            | Not Applicable                    | NA           | -1            | Yes               |
| -99            | Incomplete                        | NA           | -2            | Yes               |
| NA             | Unanswered                        | NA           | NA            | Yes               |

```{r}
int_qns <- 
  c( staff_qns_int, 
     people_served_qns_int, 
     fundraise_donor_qns_int )

COLUMNS <- int_qns

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>%
  lapply( recode_x, pattern=c("N/A","-99"), replace=c("Inf","Inf") )

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>%
  lapply( as.numeric )

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>%
  lapply( memisc::as.item, missing.values=Inf )

survey_df[ COLUMNS ] <- purrr::map( COLUMNS, add_q_details, survey_df )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html(codebook( survey_df[ COLUMNS[1] ] ))
```

# Numeric Inputs

These questions accept a numeric input from users to denote dollar values. For some variables, additional processing is done to remove commas and "\$" signs.

| Original Value | Description   | Recode Label | Recode Value  | Code as Missing ? |
|---------------|---------------|---------------|---------------|---------------|
| Dollar Amount  | Dollar Amount | NA           | Numeric Value | No                |
| -99            | Incomplete    | NA           | -1            | Yes               |
| NA             | Unanswered    | NA           | NA            | Yes               |

```{r, warning=FALSE}
numeric_qns <- 
  c( majorgift_qn_num, 
     reserve_qns_num, 
     cares_qns_num, 
     finance_revenue_qns_num )

COLUMNS <- numeric_qns

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>% 
  lapply( keep_numbers )

survey_df[ COLUMNS ] <- 
  survey_df[ COLUMNS ] %>%
  lapply( memisc::as.item, missing.values=Inf )

survey_df[ COLUMNS ] <- purrr::map( COLUMNS, add_q_details, survey_df )
```

```{r, eval=F, echo=F}
codebook( survey_df[ COLUMNS[2] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html( codebook( survey_df[ COLUMNS[1] ] ))
```

# Text Inputs

These questions allow the user to enter raw text as answers. All non-text values are converted to NAs.

```{r}
text_qns <- 
  c( staff_qns_text, 
     finance_chng_qns_text, 
     finance_revenue_qns_text, 
     fundraise_qns_text, 
     leadership_chng_qns_text, 
     primary_cncrn_qn_text, 
     program_change_qns_txt, 
     race_gender_qns_text)

survey_df[ text_qns ] <- 
  survey_df[ text_qns ] %>%
  lapply( recode_x, pattern="-99", replace=NA )

survey_df[ text_qns ] <- 
  survey_df[ text_qns ] %>%
  lapply( memisc::as.item )

survey_df[ text_qns ] <- purrr::map( text_qns, add_q_details, survey_df )

codebook( survey_df[ text_qns[1] ] )
```

```{r, eval=F, echo=F}
# codebook( survey_df[ COLUMNS[1] ] )
```

**Example:**

```{r, results="asis", echo=F}
show_html( codebook( survey_df[ text_qns[1] ] ))
```

```{r, echo=F}
#### 
####   CLEANUP
#### 

# temp file for use in next chapter 

fpath <- "DATA-PREP/03-year-three/02-data-intermediate/"
fname <- "SURVEYDF-step31.csv"
write.csv( survey_df, paste0( fpath, fname ), row.names=F )

rdsname <- "SURVEYDF-step31.rds"
saveRDS( survey_df, paste0( fpath, rdsname ) )
```

```{=html}
<style>

h1, h2 {
  margin-top: 80px
}

.codebook-entry {
   background-color: beige;
   margin-top: 20px;
}
</style>
```
